## 义码当仙之设计模式

### 概念
是一套被反复使用、多数人知晓、经过分类编目的优秀代码设计经验的总结。使用设计模式是为了重用代码，使代码更易理解并保证代码的可靠性。  

### 设计原则

> 单一职责原则（Single Responsibility Principle，简称SRP）

- 一个类，只有一个引起它变化的原因，应该只有一个职责。
- 提出一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计是否优良，但“职责”或“变化原因”都是不可度量的，因项目而异，因环境而异。

> 里氏替换原则（Liskov Substitution Principle，简称LSP）

- 所有引用基类的地方必须能透明地使用其子类对象，反之则不行。
- 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。
- 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系替代继承。
- 策略模式、组合模式、代理模式

> 依赖倒置原则（Dependence Inversion Principle，简称DIP）

- 高层模块不应该依赖低层模块，两者都应依赖其抽象，抽象不依赖细节，而细节依赖抽象。
- 在Java中的表现是：模块间的依赖通过抽象产生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生，接口或抽象类不依赖于实现类，实现类依赖接口或抽象类。

> 接口隔离原则（Interface Segregation Principle，简称ISP）

- 一个类对另外一个类的依赖性应当是建立在最小的接口上，使用多个专门的接口比使用单一的总接口要好。

> 迪米特法则（Law of Demeter，简称LoD）

- 一个对象应该对其他对象有最少的了解，即一个类应该对自己需要耦合或者调用的类知道得最少。
- 外观模式、中介者模式

> 开闭原则（Open-Closed Principle，简称OCP）

- 一个软件实体，如类、模块和函数应该对外扩展开放，对修改关闭。

### 分类

> 创建型（5）

创建型模式是用来创建对象的模式，抽象了实例化的过程，帮助一个系统独立于其关联对象的创建、组合和表示方式。

- 单例模式（Singleton Pattern）：
一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

- 工厂方法模式（Factory Method Pattern）：
  在工厂方法模式中，工厂类成为了抽象类，实际的创建工作将由其具体子类来完成。工厂方法的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中去，强调的是“单个对象”的变化。

- 抽象工厂模式（Abstract Factory Pattern）：
  抽象工厂是所有工厂模式中最为抽象和最具有一般性的一种形态。抽象工厂可以向客户提供一个接口，使得客户可以在不必指定产品具体类型的情况下，创建多个产品族中的产品对象，强调的是“系列对象”的变化。

- 建造者模式（Builder Pattern）：
  把构造对象实例的逻辑转移到了类的内部，在类的外部定义了该类的构造逻辑。它把一个复杂的构造过程从对象的表示中分离出来，其直接效果是将一个复杂的对象简化为一个比较简单的目标对象，强调的是产品的构造过程。

- 原型模式（Prototype Pattern）：
  原型模式和工厂模式一样，同样对客户隐藏了对象创建工作，但通过对一个类进行实例化来构造新对象不同的是，原型模式是通过复制一个现有对象生成新对象。

> 结构型（7）

顾名思义，构造型模式讨论的是类和对象的结构，它采用继承机制来组合接口或实现（类结构型模式），或者通过组合一些对象实现新的功能（对象结构型模式）。这些结构型模式在某些方面具有很大的相似性，但侧重点却各有不同。  

- 代理模式（Proxy Pattern）：
  为其他对象提供一种代理以控制对该对象的访问。

- 装饰模式（Decorator Pattern）：
  动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。

- 适配器模式（Adapter Pattern）：
  将一个类的接口变换成客户端所期待的另一个接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

- 组合模式（Composite Pattern）：
  也叫合成模式，将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

- 桥梁模式（Bridge Pattern）：
  也叫桥接模式，将抽象和实现解耦，使得两者可以独立变化。  

- 外观模式（Facade Pattern）：
  也叫门面模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易于使用。

- 享元模式（Flyweight Pattern）：
  是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象。

> 行为型（11）

行为型设计模式关注的是对象的行为，用来解决对象之间的联系问题。

- 模板方法模式（Template Method Pattern）：
  定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

- 命令模式（Command Pattern）：
  是一种高内聚的模式，将一个请求封装成一个对象，从而使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

- 责任链模式（Chain of Responsibility Pattern）：
  使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

- 策略模式（Strategy Pattern）：
  也叫政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

- 迭代器模式（Iterator Pattern）：
  提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。

- 中介者模式（Mediator Pattern）：
  用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

- 观察者模式（Observer Pattern）：
  也叫发布订阅模式，定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

- 备忘录模式（Memento Pattern）：
  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

- 访问者模式（Visitor Pattern）：
  封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作。

- 状态模式（State Pattern）：
  当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类型，状态模式的核心是封装，状态的改变引起行为的改变。

- 解释器模式（Interpreter Pattern）：
  给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该文法表示来解释语言中的句子。  

<hr>






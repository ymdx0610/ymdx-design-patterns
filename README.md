## 义码当仙之设计模式

[推荐设计模式学习站点](http://c.biancheng.net/view/1348.html)

### 概念
是一套被反复使用、多数人知晓、经过分类编目的优秀代码设计经验的总结。使用设计模式是为了重用代码，使代码更易理解并保证代码的可靠性。  

### 设计原则

> 单一职责原则（Single Responsibility Principle，简称SRP）

- 一个类，只有一个引起它变化的原因，应该只有一个职责。
- 提出一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计是否优良，但“职责”或“变化原因”都是不可度量的，因项目而异，因环境而异。

> 里氏替换原则（Liskov Substitution Principle，简称LSP）

- 所有引用基类的地方必须能透明地使用其子类对象，反之则不行。
- 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。
- 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系替代继承。
- 策略模式、组合模式、代理模式

> 依赖倒置原则（Dependence Inversion Principle，简称DIP）

- 高层模块不应该依赖低层模块，两者都应依赖其抽象，抽象不依赖细节，而细节依赖抽象。
- 在Java中的表现是：模块间的依赖通过抽象产生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生，接口或抽象类不依赖于实现类，实现类依赖接口或抽象类。

> 接口隔离原则（Interface Segregation Principle，简称ISP）

- 一个类对另外一个类的依赖性应当是建立在最小的接口上，使用多个专门的接口比使用单一的总接口要好。

> 迪米特法则（Law of Demeter，简称LoD）

- 一个对象应该对其他对象有最少的了解，即一个类应该对自己需要耦合或者调用的类知道得最少。
- 外观模式、中介者模式

> 开闭原则（Open-Closed Principle，简称OCP）

- 一个软件实体，如类、模块和函数应该对外扩展开放，对修改关闭。

> 组合/聚合复用原则（Composite/Aggregate Reuse Principle，简称CRP）
- 组合/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的。   
- 在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生了改变，则子类的实现也不得不改变；
从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了组合/聚合复用原则，也就是在实际开发设计中，尽量使用组合/聚合，不要使用类继承。

### 分类

> 创建型（5）

创建型模式是用来创建对象的模式，抽象了实例化的过程，帮助一个系统独立于其关联对象的创建、组合和表示方式。

- 单例模式（Singleton Pattern）：
一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

- 工厂方法模式（Factory Method Pattern）：
  在工厂方法模式中，工厂类成为了抽象类，实际的创建工作将由其具体子类来完成。工厂方法的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中去，强调的是“单个对象”的变化。

- 抽象工厂模式（Abstract Factory Pattern）：
  抽象工厂是所有工厂模式中最为抽象和最具有一般性的一种形态。抽象工厂可以向客户提供一个接口，使得客户可以在不必指定产品具体类型的情况下，创建多个产品族中的产品对象，强调的是“系列对象”的变化。

- 建造者模式（Builder Pattern）：
  把构造对象实例的逻辑转移到了类的内部，在类的外部定义了该类的构造逻辑。它把一个复杂的构造过程从对象的表示中分离出来，其直接效果是将一个复杂的对象简化为一个比较简单的目标对象，强调的是产品的构造过程。

- 原型模式（Prototype Pattern）：
  原型模式和工厂模式一样，同样对客户隐藏了对象创建工作，但通过对一个类进行实例化来构造新对象不同的是，原型模式是通过复制一个现有对象生成新对象。

> 结构型（7）

顾名思义，构造型模式讨论的是类和对象的结构，它采用继承机制来组合接口或实现（类结构型模式），或者通过组合一些对象实现新的功能（对象结构型模式）。这些结构型模式在某些方面具有很大的相似性，但侧重点却各有不同。  

- 代理模式（Proxy Pattern）：
  为其他对象提供一种代理以控制对该对象的访问。

- 装饰模式（Decorator Pattern）：
  动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。

- 适配器模式（Adapter Pattern）：
  将一个类的接口变换成客户端所期待的另一个接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

- 组合模式（Composite Pattern）：
  也叫合成模式，将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

- 桥梁模式（Bridge Pattern）：
  也叫桥接模式，将抽象和实现解耦，使得两者可以独立变化。  

- 外观模式（Facade Pattern）：
  也叫门面模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易于使用。

- 享元模式（Flyweight Pattern）：
  是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象。

> 行为型（11）

行为型设计模式关注的是对象的行为，用来解决对象之间的联系问题。

- 模板方法模式（Template Method Pattern）：
  定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

- 命令模式（Command Pattern）：
  是一种高内聚的模式，将一个请求封装成一个对象，从而使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

- 责任链模式（Chain of Responsibility Pattern）：
  使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

- 策略模式（Strategy Pattern）：
  也叫政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

- 迭代器模式（Iterator Pattern）：
  提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。

- 中介者模式（Mediator Pattern）：
  用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

- 观察者模式（Observer Pattern）：
  也叫发布订阅模式，定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

- 备忘录模式（Memento Pattern）：
  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

- 访问者模式（Visitor Pattern）：
  封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作。

- 状态模式（State Pattern）：
  当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类型，状态模式的核心是封装，状态的改变引起行为的改变。

- 解释器模式（Interpreter Pattern）：
  给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该文法表示来解释语言中的句子。  

<hr>

### 单例模式  
保证一个类只有一个实例，并且提供一个访问该全局访问点。  

> 示例项目：ymdx-design-patterns -> dp01-creation -> singleton

#### 应用场景
1. Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？不信你自己试试看哦～   
2. Windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。  
3. 网站的计数器，一般也是采用单例模式实现，否则难以同步。  
4. 应用程序的日志应用，一般都采用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。  
5. Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。  
6. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。  
7. 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。  
8. 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。  
9. HttpApplication 也是单位例的典型应用。熟悉ASP.Net（IIS）的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例。
10. Servlet、Spring（默认单例）、Struts2、数据库连接池、线程池、枚举、常量... 

#### 单例优缺点
优点：   
1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例。  
2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。  
3. 提供了对唯一实例的受控访问。  
4. 由于在系统内存中只存在一个对象，因此可以 节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。  
5. 允许可变数目的实例。  
6. 避免对共享资源的多重占用。  

缺点：
1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。   
2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。   
3. 单例类的职责过重，在一定程度上违背了“单一职责原则”。   
4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。  

#### 单例创建方式
1. 饿汉式：类初始化时，会立即加载该对象，线程天生安全，调用效率高。  
2. 懒汉式：类初始化时，不会初始化该对象,真正需要使用的时候才会创建该对象，具备懒加载功能。    
3. 静态内部类方式：结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。  
4. 枚举单例：使用枚举实现单例模式。优点：实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障！避免通过反射和反序列化的漏洞，缺点没有延迟加载。  
5. 双重检验锁方式：因为JVM本质重排序的原因，可能会初始化多次，不推荐使用   

#### 单例防止反射漏洞攻击
在构造函数中，只能允许初始化一次即可。  
```java
private static boolean flag = false;

private Singleton() {
    if (!flag) {
        flag = true;
    } else {
        throw new RuntimeException("单例模式被侵犯！");
    }
}
```

#### 如何选择单例创建方式
1. 如果不需要延迟加载，可以使用枚举或者饿汉式，相对来说枚举式好于饿汉式。  
2. 如果需要延迟加载，可以使用静态内部类式或者懒汉式，相对来说静态内部类式好于懒汉式。 

<hr>

### 厂方模式
实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式。  

#### 工厂模式好处
工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。  
利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。  
将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。  

### 简单工厂模式（不是23种设计模式之一）
简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。  

![](images/简单工厂模式.png)  

> 示例代码：ymdx-design-patterns -> dp01-creation -> simple_factory

#### 单工厂的优点/缺点
优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。  
缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASP（职责分配原则）。违背高内聚  

### 工厂方法模式
工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。  
该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。  

![](images/工厂方法模式.png)  

> 示例代码：ymdx-design-patterns -> dp01-creation -> factory_method

### 抽象工厂模式
抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体工厂，由具体工厂来产生具体产品。  

![](images/抽象工厂模式.png)  

> 示例代码：ymdx-design-patterns -> dp01-creation -> abstract_factory

#### 简单工厂、工厂方法、抽象工厂之小结、区别
简单工厂：用来生产同一等级结构中的任意产品。（不支持拓展增加产品）  
工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）  
抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）  

<hr>

### 代理模式
代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。  

#### 代理模式的优缺点
- 优点  
1. 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；  
2. 代理对象可以扩展目标对象的功能；  
3. 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；  

- 缺点：  
1. 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；  
2. 增加了系统的复杂度；  

#### 代理模式的结构
代理模式的主要角色如下：  
1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。  
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。  
3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。  

![](images/代理模式.png)  

#### 代理模式应用场景
SpringAOP、事务原理、日志打印、权限控制、远程调用、安全代理，可以隐蔽真实角色

#### 代理的分类
1. 静态代理（静态定义代理类）  
2. 动态代理（动态生成代理类）  
3. Jdk自带动态代理    
4. Cglib 、javaassist（字节码操作库）  

#### 静态代理  
由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。  

#### 动态代理
1. 代理对象不需要实现接口  
2. 代理对象的生成是利用JDK的API，动态的在内存中构建代理对象（需要我们指定创建代理对象／目标对象实现的接口的类型）  
3. 动态代理也叫做：JDK代理，接口代理  

#### JDK动态代理
- 原理  
是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口，面向接口生成代理，位于java.lang.reflect包下） 

- 实现方式 
1. 通过实现InvocationHandler接口创建自己的调用处理器   
InvocationHandler handler = new InvocationHandlerImpl(…);   
2. 通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类  
Class clazz = Proxy.getProxyClass(classLoader, new Class[]{…});   
3. 通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型  
Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});   
4. 通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入  
Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));  

- 缺点  
jdk动态代理，必须是面向接口，目标业务类必须实现接口  

#### CGLIB动态代理
使用cglib[Code Generation Library]实现动态代理，并不要求委托类必须实现接口，底层采用asm字节码生成框架，生成代理类的字节码  
原理：利用asm开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。  

#### CGLIB动态代理与JDK动态区别  
java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。  
而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。  
Spring中，  
1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP   
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP   
3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换  
JDK动态代理只能对实现了接口的类生成代理，而不能针对类。  
CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。  
因为是继承，所以该类或方法最好不要声明成final，final可以阻止继承和多态。  

<hr>

























  
  
















